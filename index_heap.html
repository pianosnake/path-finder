<!DOCTYPE html>
<html>
<head>
<title>Path finding on an elevation model</title>
<script src="arrays.js" type="text/javascript"></script> 
<script src="path.js" type="text/javascript"></script> 
</head>

<body>
<canvas id="myCanvas" width="341" height="487" style="float:left">Your browser does not support HTML5 canvas.<br>For ideal performance, use Chrome.<br><br></canvas>
<div style="float:left; padding-left:10px;">
    <b>Start:</b> <span id="startDiv">Click elevation model to set start point</span><br>
    <b>End:</b> <span id="endDiv">Click elevation model to set end point</span><br>
    <b>Path:</b> <span id="pathDiv"><a href='javascript:checkInputs()'>Click here to find path</a></span>
</div>
<div style="clear:both">Position: <span id="posDiv"></span></div>
<p>About</p>
<ul><li>The purpose of this aplication is to find the easiest way to hike from a starting point to an ending point over a given terrain.</li>
<li>Moving from one pixel to a neighboring pixel E,N,S or W costs 2 points.</li>
<li>Moving to a neighbor NW,NE,SW,or SE costs 3 points.</li>
<li>The absolute difference in pixel values, which represent elevation, is multiplied by 5.</li>
</ul>
<p>Notes</p>
<ul>
<li>Works fastest in Chrome. Will not even load in IE7 or earlier.</li>
<li>Image from the USGS 1/3-Arc Second National Elevation Dataset. And we're losing a lot of detail going from a TIFF to a PNG. </li>
<li>Use a binary heap to quickly get the item with the lowest f-score.  This is a tremenduous improvement over looping over arrays.</li> 
<li>Use objects to store lists for quick lookup.  Again, much faster than looping over arrays. </li>
<li>Use a stored image data instead of getImageData</li>
<li>Modify the binary heap methods to track item indexes whenver items are switched around.  This keeps us from using an expensive array lookup when items need to be updated</li> 
<li>Use the Firebug profiler to see which functions are taking too long, and focus improvements on those</li>
</ul>
<p>Questions</p>
<ul>
<li>If you start in different points in neighborhood A and end in any point in neighborhood B, it looks like a trail would be used for all those hikes.  What defines these neighborhoods? How do you find their boundaries?</li>
<li>Running the algorithm on the same picture scaled down, is much faster and the results are remarkably similar.  How much are we losing by using lower resolution data?  Is running this on the original TIFF going to give the same results as running on the reduced resolution PNG?</li>
<li>Also, the heuristic is pretty important because it is our estimate of the remaining distance.  Can the heuristic be improved by using the results from a lower resolution run?</li>
<li>Can we predict the location of existing trails? W.G. Rees isn't too hopeful in "<a href="http://www.sciencedirect.com/science/article/pii/S0098300404000226">Least-cost paths in mountainous terrain</a>" Computers &amp; Geosciences 30 (2004) 203-209.   </li> 
<li>Thomas Pingel in "<a href="http://www.ucgis.org/summer2009/studentpapers/pingel_thomas.pdf">Modeling slope as a contributor to route selection in mountainous areas</a>" notes that people overestimate slopes and are prone to making sub-optimal decisions.  Also going downhill on a steep slope is harder than going uphill the same way.  How do you account for that in the prediction? </li>
</ul>
<p>Resources</p>
<ul>
<li>Patrick Lester.  "<a href='http://www.policyalmanac.org/games/aStarTutorial.htm'>A* Pathfinding for Beginners</a>"</li>
<li>Patrick Lester. "<a href='http://www.policyalmanac.org/games/binaryHeaps.htm'>Using Binary Heaps in A* Pathfinding</a>"</li>
<li>Contact author: Florin Alexandrescu (geotangents at gmail) </li>
</ul>

</body>

</html>
