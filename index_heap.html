<html>

<body>
<html>
<script>
//from http://miloq.blogspot.com/2011/05/coordinates-mouse-click-canvas.html
document.addEventListener("DOMContentLoaded", init, false);
var context,canvas,startPt,endPt; 
//var width=341,height=487;
var width=68,height=96;


function init(){
    canvas = document.getElementById("myCanvas");
    context = canvas.getContext('2d');
    
    var img = new Image();
    img.onload = function(){
        context.drawImage(img,0,0,width,height);
     }
    //set the source of the image after you define the onload event 
    img.src = '28497307.png';
    //non IE 
    canvas.addEventListener("mousedown", getPosition, false);
}

  
function getPosition(event){
    //function called when user clicks on canvas
    
    var x,y;
    if (event.x != undefined && event.y != undefined){
        x = event.x;
        y = event.y;
    }else{
    // Firefox method to get the position
          x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
          y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }

    x -= canvas.offsetLeft;
    y -= canvas.offsetTop;
    
    if(x>width || y>height){
        //do nothing if the click is outside the canvas
        return; 
    }
    //pixel value from the image pixel array
    v = context.getImageData(x,y,1,1).data[0];
    p = x+"-"+y; 
    
        if(!startPt){
        	//define the start point.   g is the score to get to itself, its 0 in the beginning, f is a high score as a default start  
            startPt ={x:x,y:y,v:v,p:p,g:0,f:0,par:null};
           setHtml("startDiv","x "+x + " y "+ y + " v "+v); 
        }else{
           setHtml("endDiv","x "+x + " y "+ y + " v "+v);   
            endPt ={x:x,y:y,v:v,p:p}
            
        }
        
        console.log("x:",x,"y:",y," ",p);
}
function setHtml(div,html){
    document.getElementById(div).innerHTML = html; 
}


//description of algorithm from http://www.policyalmanac.org/games/binaryHeaps.htm
Array.prototype.pushHeap = function(v){
    //add item to the end 
    this.push(v);
    var l = this.length; 
    var h= Math.floor(l/2);
    var p = this[h-1];
    var vpos = l-1; 
    
    //repeat while v's f-score is lower than the parent's
    while(p && v.f<p.f ){
        //swap the parent with v
        this[h-1] = v;
        this[vpos] = p; 
        vpos=h-1; 
        h=Math.floor(h/2);
        p=this[h-1];
    }
}

Array.prototype.shiftHeap = function(v){
    if(this.length<3){
        //regular shift if there are 0,1 or 2 items in array
       this.shift(); 
        return;
    }
    //remove the first element
    this.shift();
    //put the last element first 
    this.unshift(this.pop()); 
    var pos = 0,p2;
    //the first two kids are at index 1 and 2 
    var kid1 = this[1]; 
    var kid2 = this[2]; 
    var v= this[pos]; 
    
    //repeat while parent's f-score is greater than either of its two children 
    while((kid1 && v.f>kid1.f) || (kid2 && v.f>kid2.f)){
        //swap it with the lowest of the two
        if(!kid2 || kid1.f<=kid2.f){
            //if kid 2 is undefined, swap parent with kid1 
            this[pos] = kid1; 
            pos = pos*2 +1;
        }else{
            this[pos] = kid2; 
            pos = pos*2 +2;
        }
        this[pos]=v; 
        p2 = pos*2;
        kid1 = this[p2+1];
        kid2 = this[p2+2];
    }
}

Array.prototype.idxPt=function(n){
//special function to run through open and closed arrays and return the index of points. Since we're searching on the p property of points, the regular indexOf may not sometimes work 
    for(var i=0,l=this.length;i<l;i++){
        if(this[i].x===n.x && this[i].y===n.y){
            return i; 
        }
    }
    return -1; 
}

//the open and closed lists, and the low point 
var o=[],c=[],low; 

function runAlgo(){
    //add start point to the open list.  regular push is ok since there's just one item 
    o.push(startPt);
    
    console.log("running algo",o); 
       
    //iterate through open list until the end point is in the closed list 
    while(c.idxPt(endPt)===-1){
   //for(var i=0; i<50; i++){
        iterateOpen();
    }
    console.log("done.");
    drawPath(); 
    //reset the start and end points 
   // startPt = null;
    //endPt = null; 
}


function iterateOpen(){
    //pick the point with the lowest f-score (ie the first one, since we're using a binary heap to keep the open list quasi-sorted) and move point to the closed list
    
    low = o[0];
    c.push(low);
    o.shiftHeap();
 
    
    //get the neighbors 
    var neighs = getNeighbors(low);
     
    for (var i=0,l=neighs.length;i<l;i++){
        var n= neighs[i];
        //calculate the g score for the neighbor 
        var g = n.g+low.g+n.d;
        
        if(c.idxPt(n)>-1){
        	//if it's in the closed list, ignore it
            continue; 
        }
        var oIdx =o.idxPt(n); 
        if(oIdx>-1){
            //if neighbor is in open list already check score to see if this approach is better
            var en = o[oIdx];
            if(en.g>g){
                //update the score to approaching it from this pt 
               en.g= g;
               //update the parent to this
               en.par= low.p;
            }
        }else{
            //if not in open list then add it to the open list 
            //make the parent the current point 
            n['par'] = low.p;
            n['g']= g;
            n['f']= g+n.h;
            o.pushHeap(n); 
        }
    }
}



function getNeighbors(p){
//returns an array of all the neighbors.  each point is an object with properties
// p: 'x-y'  the written form of the point
// x: x value
// y: y value 
// d: the absolute difference in pixel values of moving from p to n
// g: if the point is to the right, left, up or down then a 2.  if diagonal then a 3 
// h: the heuristic, the manhattan distance to get from this point to the endPt
// f: the sum of g and h 

    var neighs = [];
    var curVal = context.getImageData(p.x,p.y,1,1).data[0]; 
    for (var i=-1;i<2;i++){
    	//stay within the x bounds of the image 
        if(p.x+i>=0 && p.x+i<width){
	        for (var j=-1;j<2;j++){
	        	//stay within the y bounds of the image, and ignore when loop gives same point as p 
	            if(p.y+j>=0 && p.y+j<height && (j || i)){
	                var pi = p.x+i; 
	                var pj = p.y+j; 
	                var neighVal = context.getImageData(pi,pj,1,1).data[0];
	                	var n ={
	                        p:pi+'-'+pj,
	                        x:pi,
	                        y:pj,
	                        d:Math.abs(curVal-neighVal)*5,
	                        g:(pi!=p.x && pj!=p.y)?3:2,
	                        h:Math.abs(endPt.x-pi)+Math.abs(endPt.y-pj)
	                    };
	                neighs.push(n); 
	           }	   
	        }
       } 
    }
    return neighs; 
}


function drawPath(){
    var idx = c.idxPt(endPt); 
    var par =c[idx].par;
    var ct=0;
    context.strokeStyle = "red"; 
    context.beginPath();
    context.moveTo(endPt.x, endPt.y);
	
    while(par){
        ct++; 
        idx = c.idxPt({p:par});
        context.lineTo(c[idx].x, c[idx].y);
        par =c[idx].par; 
	}
    context.stroke();
    setHtml("pathDiv","points "+ct + " difficulty "+c[c.idxPt(endPt)].g );
}
</script> 

<body>
<canvas id="myCanvas" width="341" height="487" style="float:left"></canvas>
<div style="float:left; padding-left:10px;">Click elevation model twice to set start and end points<br>
    Start: <span id="startDiv"></span><br>
    End: <span id="endDiv"></span><br>
    Path: <span id="pathDiv"></span>
    <p><a href='javascript:runAlgo()'>Find path</a></p>
</div>
</body>

</html>
