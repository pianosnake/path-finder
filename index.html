<html>

<body>
<html>
<script>
//from http://miloq.blogspot.com/2011/05/coordinates-mouse-click-canvas.html
document.addEventListener("DOMContentLoaded", init, false);
var imageData,context,canvas; 
var width=341,height=487;
var startPt={};
var endPt={}; 


function init(){
    canvas = document.getElementById("myCanvas");
    context = canvas.getContext('2d');
    var img = new Image();
    img.onload = function(){
        context.drawImage(img,0,0);
     }
    //set the source of the image after you define the onload event 
    img.src = '28497307.png'; 
    canvas.addEventListener("mousedown", getPosition, false);
}

  
function getPosition(event){
    //function called when user clicks on canvas
    
    var x,y;
    if (event.x != undefined && event.y != undefined){
        x = event.x;
        y = event.y;
    }else{
    // Firefox method to get the position
          x = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
          y = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }

    x -= canvas.offsetLeft;
    y -= canvas.offsetTop;
    //pixel value
    v = context.getImageData(x,y,1,1).data[0];
    p = x+"-"+y; 
    
        if(!startPt.x){
        	//define the start point.   g is the score to get to itself, its 0 in the beginning, f is a high score as a default start  
            startPt ={x:x,y:y,v:v,p:p,g:0,f:1000000};
           setHtml("startDiv","x "+x + " y "+ y + " v "+v); 
        }else{
           setHtml("endDiv","x "+x + " y "+ y + " v "+v);   
            endPt ={x:x,y:y,v:v,p:p}
            changeColor(x,y);
        }
        
        console.log("x:",x,"y:",y," ",p);
}
function setHtml(div,html){
    document.getElementById(div).innerHTML = html; 
}
function changeColor(x,y){
    var i = context.createImageData(1,1);
    //keep the first color the same so that we can still compute the algorithm based on it
    //but change the other two so we can see a different color 
    i.data= [context.getImageData(x,y,1,1).data[0],255,0,255];
    context.putImageData(i,x,y);
}

//the 'everything' object holds the open/closed list, parents, g and f scores 
//key is the a point named 'x-y' and value is an array [open/closed,parent,fscore,gscore]
var e={}; 
//lowest cost point 
var lcpt; 


function runAlgo(){
 

    //add start point to the open list 
    e[startPt.p]=[1,null,0,0];
    lcpt = startPt;
    
       console.log("running algo,lcptis",lcpt); 
       
    //iterate through open list until the end point is in the closed list 
    while(!ptOpenOrClosed(endPt,0)){
   // for(var i=0; i<50; i++){
        iterateOpen();
    }
    drawPath(); 
}
function ptOpenOrClosed(a,b){
    //return true is point is in 'e' and if the first item in its array is a 0 (for closed) 
    if(e[a.p]){
        if(e[a.p].o==b){
            return true;
        }else{
            return false; 
        }
    }else{
        return false; 
    }
}
function iterateOpen(){
    //pick the point with the lowest score and move point to the closed list
    pickLowestPoint(); 
    e[lcpt.p].o=0;
    
    //get the neighbors 

    var neighs = getNeighbors(lcpt);
     
    for (var i=0,l=neighs.length;i<l;i++){
        var n= neighs[i]; 
        if(ptOpenOrClosed(n,0)){
        	//if it's in the closed list, ignore it
            continue; 
        }
        
        if(ptOpenOrClosed(n,1)){
            //if in open list check score to see if this approach is better
            var en = e[n.p];
            if(en.g>(n.g+lcpt.g+n.d)){
                //update the score to approaching it from this pt 
               en.g= n.g+lcpt.g+n.d;
               //update the parent to this
               en.par= n.p; 
              // console.log("!!upd ",en.p);
            }
        }else{
            //if not in open list then add it to the open list 
            //make the parent the current point 
            e[n.p]=n;
            e[n.p]['par'] = lcpt.p;
            e[n.p]['o']= 1;
            e[n.p]['g']= n.g+lcpt.g+n.d;
            e[n.p]['f']= n.g+lcpt.g+n.d+n.h;
            //console.log('enp is now',e[n.p]);
            //we're adding a new point to the open list, so check to see if it has a low score
            
        }
        
    }
}
function pickLowestPoint(){
	var f = 10000; 
	for (var i in e){
		if(e[i].o && e[i].f <f ){
			f=e[i].f; 
			lcpt = e[i];
		}	
	}
}
	

function isThisLowest(n){
    if(n.f<lcpt.f){
        lcpt = n; 
    }
}

function getNeighbors(p){
//returns an array of all the neighbors.  each point is an object with properties
// p: 'x-y'  the written form of the point
// x: x value
// y: y value 
// d: the absolute difference in pixel values of moving from p to n
// g: if the point is to the right, left, up or down then a 2.  if diagonal then a 3 
// h: the heuristic, the manhattan distance to get from this point to the endPt
// f: the sum of g and h 

    var neighs = [];
    var curVal = context.getImageData(p.x,p.y,1,1).data[0]; 
    for (var i=-1;i<2;i++){
    	//stay within the x bounds of the image 
        if(p.x+i>=0 && p.x+i<width){
	        for (var j=-1;j<2;j++){
	        	//stay within the y bounds of the image, and ignore if when the neighbor given the same point 
	            if(p.y+j>=0 && p.y+j<height && (j || i)){
	                var pi = p.x+i; 
	                var pj = p.y+j; 
	                var neighVal = context.getImageData(pi,pj,1,1).data[0];
	                	var n ={
	                        p:pi+'-'+pj,
	                        x:pi,
	                        y:pj,
	                        d:Math.abs(curVal-neighVal),
	                        g:(pi!=p.x && pj!=p.y)?3:2,
	                        h:Math.abs(endPt.x-pi)+Math.abs(endPt.y-pj)
	                    };
	                neighs.push(n); 
	           }	   
	        }
       } 
    }
    return neighs; 
}

function drawPath(){
	var par =e[endPt.p].par;
	changeColor(e[par].x,e[par].y);
	while(e[par]){
		par =e[par].par;
		changeColor(e[par].x,e[par].y);
	}
}
</script> 

<body>
<canvas id="myCanvas" width="341" height="487"></canvas>
<div id="startDiv">Start Point</div>
<div id="endDiv">End Point</div>
<p><a href='javascript:runAlgo()'>Run algo</a></p>
</body>

</html>
